TODO:
收集可以回答解决问题的万能语句，使用了xxx技术，解决了xxx，避免了xxx；类似于这样的话；
### auto关键字
编译器通过表达式自动推导变量类型；在复杂的项目中可以让代码更为简洁，清晰；
比如在使用迭代器遍历场景中使用
### 范围for
通过索引可以遍历容器中元素，也可以使用for循环＋迭代器，新特性范围for可以结合auto自动推导容器中元素的类型，达到遍历的目的，代码更为简洁；
如果你不想要修改容器中的元素，或者容器中的元素是大对象的话，使用`const auto&`避免不必要的拷贝；
`auto&`指的是推导变量的类型后，返回其引用类型，如果不想修改再加上`const`关键字来修饰；

### 智能指针

智能指针通过封装原始指针来进行管理内存，再不需要的时候进行释放。减少内存泄露的风险；

std::unique_ptr 对指针指向内存享有独占所有权，不能转移控制权；当离开作用域时，自动销毁，是线程安全的。

std::shared_ptr 对指针指向内存是共享的，通过引用计数来统计对内存的使用权，当引用计数为0时，销毁内存；

std::unique_ptr<classtype> intp = std::make_unique<classtype>();

std::shared_ptr<classtype> shrptr = std::make_shared<classtype>();
调用函数use_count()：可以获得引用计数的值；

使用场景：在管理多个对象，并且对资源的使用是共享的时候使用shared_ptr,反之则使用unique_ptr还能避免维护引用计数的开销；

### 右值引用和移动语义

移动语义：在传递数据时，将未来不再使用或者将要被销毁的对象赋值给新对象，让新对象来进行管理数据，减少了一次内存拷贝；

优化内存管理和性能的重要内容；
解决了传统的c++内存效率，特别在对象拷贝和传递过程中，减少了不必要的内存拷贝；操作系统有一系列的技术：写时复制、dma、零拷贝等概念，可以做一些关联；

在明白右值引用前要明白什么是右值，什么是引用，引用不用说，右值就是一指不再继续使用的临时对象或者临时变量、字面量等；右值引用可以绑定到这些对象，而不是复制他们，想来也是如果是值拷贝就不会使用引用和指针了；

**移动语义**核心是move，将左值转为右值引用，移动资源而不是复制他们，尤其是在一些大对象拷贝的场景。

类中实现移动拷贝传入参数是&&;
使用场景：比如vector容器的扩容中，不是复制而是移动之前的对象；rvo优化中发挥作用，可以大大提升性能，使用移动语义和rvo可以减少不必要的拷贝，尤其是返回临时对象或者返回大量数据的场景下，使用移动语义会强制调用移动拷贝构造函数，


RVO是一种编译器优化技术，g++中默认是开启的，可以通过`g++ -O2 -fno-elide-constructors -o main main.cpp
`来关闭，在关闭rvo情况下，依然可以通过移动语义的使用来进行资源的移动，调用移动拷贝构造函数；也可以显示返回临时对象让rvo失效，因为rvo一般是用再返回局部变量；

### nullptr
空指针常量，相比于NULL来说是类型安全的，NULL在c++中就是一个宏定义，本质是一个int，nullptr在c++中是关键字，类型安全好；

### explicit
用在构造函数中可以避免隐式转换，好处是一可以提高代码的可读性和可维护性；二是避免编译器的自动转换，导致难以追踪的错误；

### default 和 delete

使用编译器提供的默认函数，不需要自己定义；
删除默认提供的构造函数，需要自己实现；

### lambda表达式
语法：`[](){}`
[]捕获外部变量的方式，()参数， {}函数体；
[]捕获的方式，[=]传值，[&]传引用，[this]传this指针；

### constexpr
常量函数必须是常量表达式，在编译时计算出值，要求表达式中都是常量也就是参数和返回值必须是常量

可以用于指定数组大小，c++11以后，const变量同样也可以用来指定数组大小；
在编译时就确定大小；常量表达式也是在编译时就计算出大小；


### 并发编程std::thread库

并发编程提高编程的性能，尤其是在处理IO密集型任务、并行编程和任务调度的场景中；
并发编程考虑线程创建、线程分离、线程等待、线程销毁；
相应接口：构造函数创建线程，参数是函数指针和传入的参数，join()等待线程结束被主线程回收，或者说主线程要在回收子线程之后才能退出；


**线程同步机制**：包括线程互斥和线程通信；使用互斥量来处理临界区的线程安全，使用信号量和条件变量来处理线程竞争问题；

由于多线程的调度是无序的，需要对共同访问的区域进行保护；需要做线程同步。
**锁机制** mutex ,lock unlock保护临界区的有序访问；
也可以使用lock_gurad来简化对锁的管理，类似于智能指针的使用，会在作用域结束后解锁

`std::condition_variable` 是一种常见的线程同步工具，它允许线程在等待某个条件时被阻塞，并在条件满足时被唤醒。
wait() notify_one() notify_all()
应用场景是在生产者消费者场景中
在多线程开发中锁的库：lock_guard\unique_lock，前者自动管理锁的回收，后者可以手动加解锁并支持条件变量；


xxxxdetach()分离线程，可以让子线程自己回收自己，主线程不必等待；


### 完美转发std::forward
在参数传递的过程中参数的类别（左值还是右值）

### std::static_assert
编译期进行断言处理，如果条件不成立，就会编译报错；

### 数组容器std::array
类似于vector，但不支持动态扩容，内存空间是连续的，初始化时固定大小
支持的方法有 begin() end() size() data() front() back() operator[]() at() swap() assign()

### std::tuple
类似于结构体，但支持多个元素的存储和访问，支持的方法有 ：get()，tie()，size()，empty()，swap()等；
是一个泛型容器。类似于std::pair但是存放的数据类型更多；std::tie() 可以同时绑定多个变量；

### 新增了unordered_map\unordered_set
unordered_map和unordered_set是map和set的无序版本，map和set是有序;
查询效率提高，底层使用的是hash函数。
相关接口 ：insert() erase() find() size() empty() swap()等；
