TODO:
收集可以回答解决问题的万能语句，使用了xxx技术，解决了xxx，避免了xxx；类似于这样的话；
从技术发展路径和应用解决思路来掌握一门技术，在我看来更容易了解全局和深刻理解一种技术的本质；
### auto关键字
告诉编译器通过表达式等来自动推导变量类型；在复杂的项目中可以让代码更为简洁，清晰；
比如在使用迭代器遍历场景中使用。

但是也降低了代码的可读性性，对于想明确知道返回值类型或者传入参数类型的方法中，不要避免使用auto关键字

### nullptr
空指针常量，相比于NULL这种宏定义来说是类型安全的，支持在编译器进行类型检查；NULL在c++中就是一个宏定义，本质是一个int，nullptr在c++中是关键字，类型安全；
nullptr关键字，c++11引入的，因为之前NULL本质上是int，因此在一些场景下可能会引发歧义；比如在函数有指针和整型变量两种参数的函数重载版本；传入NULL会产生歧义；

```c++
void foo(int);
void foo(char*);
//函数重载中会调用哪一个呢，其实会调用第一个，而不是pointer类型；
//函数中传入空指针是常见的。
foo(NULL);
```

nullptr是关键字；只能用于指针类型；

NULL是宏，本质上是一个整型0；

### explicit
用在构造函数中可以避免隐式转换，好处是一可以提高代码的可读性和可维护性；二是避免编译器的自动转换，导致难以追踪的错误；必须进行类型匹配和类型转换；

### default 和 delete

使用编译器提供的默认函数，不需要自己定义；
删除默认提供的构造函数，需要自己实现；

### constexpr
常量函数必须是常量表达式，在编译时计算出值，要求表达式中都是常量也就是参数和返回值必须是常量。

声明的常量和常量表达式可以用于指定数组大小，c++11以后，const变量同样也可以用来指定数组大小；
在编译时就计算出大小；常量表达式也是在编译时就计算出大小；

### 后置返回值类型：

在泛型编程中结合`decltype`或其他表达式的类型来延迟推导返回值类型，和auto配合在编译时期确定；->decltype(auto a)

### 完美转发std::forward
在参数传递的过程中参数的类别（左值还是右值）
基础类型、分支结构、面向对象；

是一个模板函数，有两个参数类型，一个是模板参数、一个是函数参数；根据传入模板参数的类型将函数参数保持类型不变传递给相应的函数版本；

根据模板参数的类型，将参数以该类型进行传递，模板函数推导的类型

神奇的一点就是引用折叠规则，比如完美转发中的模板类型T&&，看T推导为什么类型，会引发引用折叠，折叠规则如下：

```c++
T& &  T& && T&& & 折叠为T&；左值引用
T&& && 折叠为T&&；右值引用
```

那如果写成T&&的参数；参考折叠规则，最终如果T类型为&，则是左值引用，如果是&&则是右值引用；

参考文章

[C++的std::move与std::forward原理大白话总结_std::move std::forward-CSDN博客](https://blog.csdn.net/newchenxf/article/details/117995131)


### std::static_assert
是一个c++关键字；

在编译期间进行断言处理，如果条件不成立，就会编译报错；

使用的方法：`static_assert(expr, statusInfo)`如果编译期间出错则显示statusInfo

### 范围for
通过**索引**可以遍历容器中元素，也可以使用for循环＋迭代器，新特性范围for可以结合auto自动推导容器中元素的类型，达到遍历的目的，代码更为简洁；
如果你不想要修改容器中的元素，或者容器中的元素是大对象的话，使用`const auto&`避免不必要的拷贝；
`auto&`指的是推导变量的类型后，返回其引用类型，如果不想修改其内容再加上`const`关键字来修饰；

### 智能指针

本质上是用来管理资源，自动对资源进行释放；
智能指针通过封装原始指针来管理指针指向的内存空间，自动释放内存空间，减少内存泄露的风险；

集中智能指针：unique_ptr、shared_ptr、wake_ptr；有一个make_xxx方法来进行创建智能指针；

std::unique_ptr 对指针指向内存享有独占所有权，不能转移控制权；当离开作用域时，自动销毁，是线程安全的。所谓线程安全及时不可重入的；

std::shared_ptr 对指针指向内存是共享的，通过引用计数来统计对内存的使用权，当引用计数为0时，销毁内存；

std::unique_ptr<classtype> intp = std::make_unique<classtype>();

std::shared_ptr<classtype> shrptr = std::make_shared<classtype>();
调用成员方法use_count()：可以获得引用计数的值；

使用场景：在管理多个对象，并且对资源的使用是共享的时候使用shared_ptr,反之则使用unique_ptr还能避免维护引用计数的开销；

### 右值引用和移动语义

在明白右值引用前要明白什么是右值，什么是引用，引用不用说，右值指不再继续使用的临时对象或者临时变量、字面量等；右值引用可以绑定到这些对象，而不是复制他们，想来也是如果是值拷贝就不会使用引用和指针了；

移动语义：在传递数据时，将未来不再使用或者将要被销毁的对象赋值给新对象，让新对象来进行管理数据，减少了一次内存拷贝；

优化内存管理和性能的重要内容；
解决了传统的c++内存效率，特别在对象拷贝和传递过程中，减少了不必要的内存拷贝；操作系统有一系列的技术：写时复制、dma、零拷贝等概念，可以做一些关联；


**移动语义**核心是move方法，可以将左值转为右值引用，移动资源而不是复制他们，尤其是在一些大对象拷贝的场景中使用可以提高效率；

类中实现移动拷贝传入参数是&&;
使用场景：比如vector容器的扩容中，不是复制而是移动之前的对象；rvo优化中发挥作用，可以大大提升性能，使用移动语义和rvo可以减少不必要的拷贝，尤其是返回临时对象或者返回大量数据的场景下，使用移动语义会强制调用移动拷贝构造函数，


RVO是一种编译器优化技术，g++中默认是**开启**的，可以通过`g++ -O2 -fno-elide-constructors -o main main.cpp
`来关闭，在关闭rvo情况下，依然可以通过移动语义的使用来进行资源的移动，调用移动拷贝构造函数；也可以显式返回临时对象让rvo失效，因为rvo一般是用在返回局部变量时；
如果未关闭rvo，则优化返回局部变量会调用一次拷贝，如果关闭则会拷贝两次，如果这时候使用移动语义只会拷贝一次；


### lambda表达式
语法：`[](){}`
[]捕获外部变量的方式，()参数， {}函数体；
[]捕获的方式，[=]传值，[&]传引用，[this]传this指针；


### 并发编程std::thread库

并发编程提高编程的性能，尤其是在处理IO密集型任务、并行编程和任务调度的场景中；
并发编程考虑线程创建、线程分离、线程等待、线程销毁；
相应接口：构造函数创建线程，参数是函数指针和传入的参数，join()等待线程结束被主线程回收，或者说主线程要在回收子线程之后才能退出；


**线程同步机制**：包括线程互斥和线程通信；使用互斥量来处理临界区的线程安全，使用信号量和条件变量来处理线程竞争问题；

由于多线程的调度是无序的，需要对共同访问的区域进行保护；需要做线程同步。
**锁机制** mutex ,lock、unlock保护临界区的有序访问；进行线程同步；
也可以使用lock_gurad来简化对锁的管理，资源获取即初始化RAII类似于智能指针的使用，会在作用域结束后解锁；
使用unique_lock可以更灵活，可以手动加解锁，支持移动语义，把锁的所有权转移给unique_lock对象；lock、unlock；和lock_guard区别；unique_lock可以结合条件变量，来进行线程通信，lock_guard不支持移动语义；

`std::condition_variable` 是一种常见的线程同步工具，它允许线程在等待某个条件时被阻塞，并在条件满足时被唤醒。
wait() notify_one() notify_all()
应用场景是在生产者消费者场景中
在多线程开发中锁的库：lock_guard\unique_lock，前者自动管理锁的回收，后者可以手动加解锁并支持条件变量；


xxxxdetach()分离线程，可以让子线程自己回收自己，主线程不必等待；


### 数组容器std::array
标准库中的数组，是固定长度的；类似于vector，但不支持动态扩容，内存空间是连续的，初始化时固定大小；
支持的方法有 begin() end() size() data() front() back() operator[]() at() swap() assign()

### std::tuple
类似于结构体，但支持多个元素的存储和访问，支持的方法有 ：get()，tie()，size()，empty()，swap()等；
是一个泛型容器。类似于std::pair但是存放的数据类型更多；std::tie() 可以同时绑定多个变量或者左值引用，用于解包tuple类型，类似于python的解包；c++17引入了结构化绑定更和python相似了。

### 新增了unordered_map\unordered_set
unordered_map和unordered_set是map和set的无序版本，map和set是有序;
查询效率提高，底层使用的是hash函数。
相关接口 ：insert() erase() find() size() empty() swap()等；

### 面向对象的三大特性：
封装继承多态。

封装：把数据和操作数据的方法封装在一起，保护了数据的访问权限和安全性；使用创建对象的方法把数据放到一个空间中，方也放在制定位置，操作数据也更为便携。

继承：相对于原有的设计，继承就是把原先的类全部拷贝下来，并且可以丰富一些方法和数据，起到扩展的目的，是一种复用的概念；

多态：我的理解就是一种接口多种实现，通过继承和虚函数机制，扩展出来了多种实现，并且通过接口中传入的对象类型达到扩展的效果；具体实现，继承子类具有和父类相同的数据和方法，并且可以重写父类的方法作为自己的方法；

虚函数，父类中的虚函数在子类实现那就是重写override，如果不是虚函数，在子类只是进行了隐藏；

内存空间是：代码段、数据段、堆、栈；

其中虚函数表存储在数据段，具体方法存储在代码段；

每一个类都有自己的虚函数表，子类的虚函数表和父类的虚函数表是不同的 。创建对象的时候，对象空间就有虚函数表指针，指向自己类的虚函数表；运行时根据类型来查找虚函数表进行来定位到指定函数执行；而对于类中的普通方法，编译器进行了静态绑定，也就是编译期就确定了，而不是运行时进行绑定；

创建对象的**内存空间分布**，从低地址到高地址：虚函数表指针、基类成员变量、按照生命顺序继承的成员变量、子类成员变量；成员变量的顺序按照声明顺序进行排列；在次期间需要考虑**空间对齐**；

创建的对象是在栈上还是堆上？

看是否通过new创建来看是分配在堆上还是栈上，如果是全局或静态变量那么在全局或静态区；

**类的设计**

类内包含：构造函数、默认构造、拷贝构造、拷贝赋值、析构函数、虚析构函数；

关键字的使用：delete、default、explicit、

## 模板函数的实例化时间

发生在编译期间；编译器根据传入的参数类型或者模板定义，通过隐式或者显式来生成相应的函数版本；

**优势**：代码复用写出与类型无关的代码，类型安全因为在函数编译期间进行了类型检查；性能优化，生成的代码是根据具体的类型进行优化。

**劣势**：是增加了编译时间；代码膨胀；



**模板的全特化**：针对类模板、函数模板；`template<>  void func<int, int >(){}`

**模板的偏特化**：针对类模板，包括范围【但是必须保持一个是模板类型参数为未特化】、类型【指针、引用、常量版本】	`template <typename T> class A<T, int> {};`

掌握模板的底层原理和各种用法，可以帮助我们对代码进行优化和调优；
