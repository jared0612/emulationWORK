1. 条件式预编译

   1. 主要是防止宏定义或者变量的重命名和重复包含头文件

2. 尖括号和双引号的包含区别

   1. 尖括号是系统内置库，会优先搜索当前系统库存在的路径，
   2. 双引号，会从当前工程中开始搜索；或者指定搜索路径；

3. 全局变量和局部变量在内存角度来看是否有区别

   1. 全局，内存存储区域在数据段的静态数据区；
   2. 局部变量，存储在栈上，生命周期随着模块作用域结束而消亡；

4. 为什么gets函数不是安全的？

   1. 有缓存区溢出的风险，因为不检查输入的长度，用户可以输入任意长度文本
   2. 无法读取换行符，在读取到换行符时进行停止读取，并且不会读取换行符；可能导致数据丢失；
   3. c11已被移除；

5. 栈溢出通常有什么原因产生的？

   1. 栈区一直在入栈，并没有被回收；

   2. 没有回收内存或者调用深度过深

   3. ```C++
      void fun() {
          while(1) {
              fun();
          }
      }
      ```

6. 简述gcc编译过程？

   1. 预处理、编译、汇编、链接
   2. 预处理：处理文本文件中的预处理指令、文本替换、注释消除、条件编译
   3. 编译：将预处理后的文件，进行编译，成成汇编代码，包括进行语法分析、词法分析、语义分析；确保不会出现语法错误
   4. 汇编：将汇编代码生成能被机器识别的二进制代码；
   5. 链接：将多个二进制目标文件和所需的库文件链接成一个可执行文件，最终生成可执行文件；

7. 局部变量和全局变量是否可以同名

   1. 可以，局部变量会在作用域内优先使用；
   2. 会对全局变量覆盖；

8. 如何引用一个已经声明在其他文件中的全局变量

   1. 使用其他文件的变量，extern关键字进行声明的变量可以在其他文件中使用；
   2. 注意变量只有一次定义，可以多次声明；

9. 同名的全局变量可以在多个.c文件中声明？

   1. 可以，但是在一个项目中，应该避免命名冲突；
   2. 可以使用static，限定改全局变量的作用域于本文件；

10. 枚举类型的使用；

    1. 枚举常量从0开始，往后开始自增一；

    2. 如果修改了枚举的常量值，从修改的位置以后的值自增1；

    3. ```C++
       enum Enum {
           x1,
           x2,
           x3 = 4,
           y1,
           y2
       };
       x1 = 0
       x2 = 1
       x3 = 4
       y1 = 5  // 继承 x3 + 1
       y2 = 6  // 继承 y1 + 1
       ```

11. 堆和栈的区别？

    1. 堆区是一个内存区域，由程序员手动分配和释放的空间
    2. 由操作系统进行管理，
    3. 空间大小上堆比较大，栈比较小；

12. static的作用

    1. 修饰局部变量
    2. 修饰全局变量
    3. 修饰函数

13. 简历上的项目经历，一般问的很细，在此基础上考察项目中利用到的基础知识；

14. IIC协议，属于通信协议的一种

15. UART

16. SPI

17. 程序的内存分配

    1. 堆、栈、BSS段、静态区（数组区、代码区）
    2. 栈有系统管理，存储临时的局部变量，函数形参，返回值，栈空间比较小，不能过度申请，不然会造成内存溢出
    3. 堆空间，由程序员进行申请和释放，如果不及时释放程序结束会别系统进行回收，如果在使用中使用后不及时回收，可能导致内存泄漏，也就是说改内存已经不再使用，但是仍不可以被再次申请，导致堆空间的碎片和不连续；
    4. bss段，存储的是未初始化的全局变量和静态变量；
    5. 数据段，存储的全局变量和静态变量
    6. 代码段，存储的程序代码

18. 单片机的中断流程

    1. 中断产生、中断处理、中断服务函数
    2. 中断就是CPU因为内部、外部、设定好的程序引起要中断正在运行的程序，转而执行中断服务子程序，待中断服务子程序执行完毕，继续执行未完成的程序；
    3. 中断处理过程：1、保护现场，将当前的pc值压入栈中（包括状态寄存器和通用寄存器信息）；2、跳转到终端服务程序，执行中断服务程序；3、回复现场，将栈顶的值送回给pc；4、跳转到被中断的位置开始执行下一个指令；

19. 多线程问题：那应该包括进程和线程的区别，进程的创建和管理调度，线程的概念、线程调度、多线程通信要考虑线程同步

20. strcpy和sprint和memcpy的区别；

    1. strcpy是逐个字符进行拷贝，返回目标字符串的指针，也就是起始位置
    2. sprint是往一段缓存中进行拷贝
    3. memcpy则是将内存拷贝到新开辟的内存空间中；

21. malloc与calloc的区别

    1. malloc开辟一段size大小的内存空间，并用一个指针变量来接收；只有一个参数，并不会初始化内存空间；
    2. calloc给出两个参数， 一个元素个数，一个元素大小，并且初始化为0，；

22. 问一些Linux常用命令

23. 引用和指针的区别：

    1. 引用，初始化时绑定，相当于变量的别名
    2. 指针，指向变量的内存区域，存储变量的内存地址，可以指向null
    3. 两者都可以修改数据，可以用在传参中，对于引用来说不用去考虑是否为空

24. const与宏的区别

    1. const修饰的变量支持类型检查，宏定义只是文本替换，在预处理阶段就完成处理了；
    2. 宏还可以定义函数、方法等，但是不能大量使用，会导致预编译时间过长；

25. 用宏来求最大值和最小值

    1. \#define MAX(a,b) ( (a>b)?(a):(b))
    2. \#define MAX(a,b) ( (a<b)?(a):(b))

26. 指针的自增自减和变量的自增自减有什么区别？

    1. 考虑到指针，就得说下变量，指针的类型与变量类型一一对应，变量是给一段内存空间起了一个名字，方便操作数据，并且变量的类型也说明怎么来操作，指针的自增自减就是根据指向变量他的类型大小进行增加减少的，举例int类型
    2. 变量的自增自减，值对于值的大小进行自增自减，比如定义一个char类型字符，自增；

27. 常量和变量的区别？

    1. 常量：内存中存储的值不能修改；
    2. 变量：内存的值可以修改；

28. main函数的3个参数

    1. argc、argv、env
    2. 分别对应：参数个数，参数数组，环境参数数组；

29. sizeof和strlen区别

    1. sizeof计算存储变量所需内存的大小；
    2. strlen计算元素个数，不包括'\0'

30. 指针和数组的区别？

    1. 指针可以指向任意内存区域，可以是栈也可以是堆；
    2. 数组要么静态存储区，要么也可以在栈上，固定大小；

31. 结构体和联合体的区别：

    1. 结构体，存储不同类型数据，
    2. 联合体，同一时刻只能用一种类型存取；

32. strncpy与strcpy的区别：

    1. n，代表复制n个字符，如果源字符串小于n则用'\0'填充，不以'\0'作为截止条件
    2. strcpy则不够安全，以'\0'作为截止条件

33. 面试阶段：自我介绍、专业技能、分析项目、非技术性问题：

34. 关键字volatile有什么含义？举三个例子：
    1.  修饰变量说明该变量会被意想不到的改变，这样编译器就不会保存在寄存器中，而是在使用时去内存中读取；
    2.  常见例子：
        1.  并行设备的硬件寄存器；
        2.  一个中断服务子程序会访问到非自动变量；
        3.  多线程应用中被几个任务共享的变量；
35. 置位的方式？
    位置为1：  a |= (1 << n);
    位置为0：  a &= ~(1 << n);不改变原有数据，对于置位0的话只能0&0=0，0&1=0；任何&1则不变；
36. 绝对地址更改其值
    1.  `*(int *const)(0x67a9) = (int) 0xaa66`
37. 当表达式中存在有符号类型和无符号类型是怎么转化？
    1.  自动转换为无符号数类型
38. int a = 3, b = 7, c; c = a+++b;其中c为多少？
    运算符优先级：最后答案为10，运算后a为4；++的优先级高，并且符号解析的顺序是从左到右，所以先加后加，所以最后答案为10；
39. typedef和宏定义来创建类型别名哪个好？
    1.  typedef 创建类型别名，方便使用，并且可以修改类型，但是不能修改名字；
    2.  宏定义，可以修改名字，但是不能修改类型；
40. 使用define定义常量？
    1.  `define SEC_YEAR (365 * 24 * 60 * 60)UL`
    2.  其中需要考虑UL,无符号long类型，因为对于16位机器来说计算机结果会溢出，所以需要用UL来保证无符号long类型，
    3.  确实要考虑硬件平台和数据表示范围对于程序的影响；
41. #error的预处理指令？
    #error 预处理指令，在预处理阶段就报错，并且不进行编译；
    #warning 预处理指令，在预处理阶段就警告，但是编译不会报错；
    当程序比较大时，不确定是否在外边定义某些宏定义，为了检测可以在程序内使用`#ifdef xxx ... #error "xxx has been defined" #else ... #endif`

41. 请解释下ISR，以及如何使用ISR？
    1.  中断服务程序，中断处理程序，当中断发生时，中断处理程序会执行，并且中断处理程序会执行完之后，中断处理程序会返回到中断发生前的程序；
    2.  在中断处理程序中，不能使用`return`，因为中断处理程序会返回到中断发生前的程序，所以不能使用`return`；
    3.  中断处理程序中不能使用`break`、`continue`、`goto`、`switch`、`case`、`default`等跳转语句，因为中断处理程序会返回到中断发生前的程序，所以不能使用这些跳转语句；
