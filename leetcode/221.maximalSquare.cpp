#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

class Solution {
public:
    /**
     * @brief maximalSquare函数用于在给定的二维字符矩阵中寻找最大正方形的面积。
     * 该函数采用动态规划的方法，通过构建一个二维整数数组dp来记录以每个位置为右下角的最大正方形的边长信息，进而推导出最大正方形的面积。
     *
     * @param matrix 一个二维的字符向量引用，表示输入的矩阵，其中字符'1'表示对应的位置可以构成正方形的一部分，'0'表示不可用部分。
     * @return int 返回找到的最大正方形的面积，如果输入矩阵为空（即行数或列数为0），则返回0。
     */
    int maximalSquare(vector<vector<char>>& matrix) {
        // 获取输入矩阵的行数，用于后续循环遍历和确定动态规划数组的大小等操作
        int m = matrix.size();
        // 获取输入矩阵的第一行的元素个数，也就是矩阵的列数，同样用于后续操作
        int n = matrix[0].size();
        // 如果矩阵的行数或者列数为0，意味着矩阵为空，此时直接返回0，因为不存在正方形，提前结束函数
        if (m == 0 || n == 0) return 0;

        // 创建动态规划的二维数组dp，并进行初始化。dp的大小为(m + 1)行(n + 1)列，所有元素初始化为0。
        // 这里多开一行一列是为了方便处理边界情况，避免在动态规划递推过程中出现越界访问的问题。
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 用于记录在动态规划过程中发现的最大正方形的边长，初始化为 -1，后续会根据实际计算结果更新。
        // 这里初始化为 -1是为了方便后面判断是否整个矩阵中都没有可构成正方形的元素（如果最后还是 -1，则表示没有）。
        long long  ans = -1;//初始化为0，返回值就是直接是ans*ans

        // 从矩阵的右下角开始，按照从下往上、从右往左的顺序遍历整个矩阵，进行动态规划的状态计算。
        // 这种逆序遍历的方式符合动态规划中基于已计算出的后续状态来推导当前状态的思路。
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                // 如果当前矩阵位置对应的字符为'1'，表示该位置可以作为正方形的右下角，尝试计算以此位置为右下角的最大正方形边长。
                if (matrix[i][j] == '1') {
                    // 根据动态规划的状态转移方程来计算当前位置的最大正方形边长。
                    // 以(i, j)为右下角的最大正方形边长取决于其右、下、右下三个相邻位置（在dp数组中对应的是(i + 1, j)、(i + 1, j + 1)、(i, j + 1)）的最小边长加1。
                    dp[i][j] = 1 + min({dp[i + 1][j], dp[i + 1][j + 1], dp[i][j + 1]});
                    // 更新最大边长记录变量ans，取当前发现的最大边长和之前记录的最大边长中的较大值。
                    ans = max(ans, dp[i][j]);
                }
            }
        }

        // 判断ans是否还是初始值 -1，如果是，说明整个矩阵中都没有可构成正方形的元素，返回0；
        // 否则，返回最大正方形的面积，即最大边长的平方（ans * ans）。
        return ans == -1? 0 : ans * ans;
    }
};

int main() {
    //可以添加测试代码
    return 0;
}